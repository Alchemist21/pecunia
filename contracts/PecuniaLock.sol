//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "./verifier.sol";
import "hardhat/console.sol";
import "./mock/HeirToken.sol";

contract PecuniaLock is Context, IERC721Receiver, KeeperCompatibleInterface {
    using Counters for Counters.Counter;

    Verifier verifier;

    HeirToken public heirToken;

    event Register(bytes32 indexed boxhash, address indexed user);

    event Recharge(
        address indexed sender,
        address indexed heirAddress,
        uint256 amount,
        uint256 tokenId
    );

    event WithdrawSigned(
        address indexed user,
        address indexed to,
        uint256 amount
    );

    event FundsAdded(uint256 amountAdded, uint256 newBalance, address sender);

    event FundsTransferred(uint256 amount, address heir);

    bytes32[] private boxHashes;

    struct SafeBox {
        bytes32 boxhash;
        address user;
        mapping(address => uint256) heirToBalance;
        mapping(address => uint256) heirToTokenid;
        uint256 heirToInterval;
        uint256 lastTimeStamp;
        mapping(address => bool) withdrawSigned;
        address[] addresss;
    }

    mapping(bytes32 => SafeBox) public boxhash2safebox;

    mapping(address => bytes32) public user2boxhash;

    mapping(uint256 => bool) public usedProof;

    constructor() {
        verifier = new Verifier();
        heirToken = new HeirToken();
        heirToken.mint(address(this), "Genesis Token");
    }

    // function balanceOf(address user, address[] memory tokenAddrs) public view returns(uint[] memory bals) {
    //     bytes32 boxhash = user2boxhash[user];
    //     SafeBox storage box = boxhash2safebox[boxhash];
    //     bals = new uint[](tokenAddrs.length);
    //     for (uint i=0; i<tokenAddrs.length; i++) {
    //         address tokenAddr = tokenAddrs[i];
    //         bals[i] = box.balance[tokenAddr];
    //     }
    // }

    /**
     * @notice Check if heir is registered in the will
     * @param boxhash the hash of box
     * @param heir address of heir
     * @return bool value
     */
    function heirIsValid(bytes32 boxhash, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[boxhash].heirToBalance[heir] > 0;
    }

    /**
     * @notice Register the user
     * @param boxhash the hash of box
     * @param proof zero-knowledge proof generated by the hash of password
     * @param pswHash password hash
     * @param allHash hash of amount and password
     * @param interval time after which will amount is transffered
     */
    function register(
        bytes32 boxhash,
        uint256[8] memory proof,
        uint256 pswHash,
        uint256 allHash,
        uint256 interval
    ) public {
        SafeBox storage box = boxhash2safebox[boxhash];

        require(
            user2boxhash[_msgSender()] == bytes32(0),
            "PecuniaLock::register: one user one safebox"
        );
        require(
            box.boxhash == bytes32(0),
            "PecuniaLock::register: boxhash has been registered"
        );
        require(
            keccak256(abi.encodePacked(pswHash, _msgSender())) == boxhash,
            "PecuniaLock::register: boxhash error"
        );
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pswHash, 0, allHash]
            ),
            "PecuniaLock::register: verifyProof fail"
        );

        box.boxhash = boxhash;
        box.user = _msgSender();
        box.heirToInterval = interval;
        box.lastTimeStamp = block.timestamp;

        user2boxhash[box.user] = boxhash;
        boxHashes.push(boxhash);
        emit Register(boxhash, box.user);
    }

    /**
     * @notice assign funds to heir using boxhash
     * @param boxOwner address of box owner
     * @param boxhash the hash of box
     * @param heirAddr address of the heir
     * @param amount amount of matic assigned to heir
     * @param tokenURI token uri
     * @return tokenId of the HEIR NFT
     */
    function rechargeWithBoxhash(
        address boxOwner,
        bytes32 boxhash,
        address heirAddr,
        uint256 amount,
        string memory tokenURI
    ) public returns (uint256 tokenId) {
        require(
            amount > 0,
            "PecuniaLock::rechargeWithBoxhash: Insufficient Amount send"
        );
        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            box.boxhash != bytes32(0),
            "PecuniaLock::rechargeWithBoxhash: safebox not register yet"
        );
        box.heirToBalance[heirAddr] += amount;

        tokenId = heirToken.mint(heirAddr, tokenURI);
        box.heirToTokenid[heirAddr] = tokenId;

        box.addresss.push(heirAddr);
        emit Recharge(boxOwner, heirAddr, amount, tokenId);
    }

    /**
     * @notice assign funds to heir using address of owner
     * @param boxOwner address of box owner
     * @param heirAddr address of the heir
     * @param tokenURI token uri
     * @return tokenId of the HEIR NFT
     */
    function rechargeWithAddress(
        address boxOwner,
        address heirAddr,
        string memory tokenURI
    ) public payable returns (uint256 tokenId) {
        bytes32 boxhash = user2boxhash[boxOwner];
        uint256 amount = msg.value;
        console.log("amount deposited=", amount);
        tokenId = rechargeWithBoxhash(
            boxOwner,
            boxhash,
            heirAddr,
            amount,
            tokenURI
        );
    }

    /**
     * @notice heir needs to sign the will before the chainlink keepers send amount to his/her address
     * @param proof zero-knowledge proof genereated using password
     * @param pswHash hash of the password
     * @param allHash hash of the password and amount
     * @param boxOwner address of box owner
     */
    function withdrawSignature(
        uint256[8] memory proof,
        uint256 pswHash,
        uint256 allHash,
        address boxOwner
    ) public {
        address heir = msg.sender;
        require(!usedProof[proof[0]], "PecuniaLock::withdraw: proof used");

        bytes32 boxhash = user2boxhash[boxOwner];
        require(
            keccak256(abi.encodePacked(pswHash, boxOwner)) == boxhash,
            "PecuniaLock::withdraw: pswHash error"
        );
        require(
            heirIsValid(boxhash, heir),
            "PecuniaLock::withdraw: heir not valid"
        );

        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            box.boxhash != bytes32(0),
            "PecuniaLock::withdraw: safebox not register yet"
        );

        uint256 amount = box.heirToBalance[heir];
        console.log("amount withdrawn", amount);

        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pswHash, amount, allHash]
            ),
            "PecuniaLock::withdraw: verifyProof fail"
        );
        uint256 tokenId = box.heirToTokenid[heir];
        require(tokenId > 0, "PecuniaLock::withdraw: token id invalid");
        require(
            heirToken.getApproved(tokenId) == address(this),
            "Approval for NFT Token not given"
        );

        heirToken.burn(tokenId);
        usedProof[proof[0]] = true;

        box.withdrawSigned[heir] = true;
        emit WithdrawSigned(box.user, heir, amount);
    }

    // Chainlink Keeper Functions
    /**
     * @notice Get the all the wills/boxes which have matured
     * @return array of boxes/wills which have matured
     */
    function getMaturedBoxes() public view returns (bytes32[] memory) {
        bytes32[] memory t_boxHashes = new bytes32[](boxHashes.length);
        uint256 count = 0;
        for (uint256 i = 0; i < boxHashes.length; i++) {
            bytes32 bh = boxHashes[i];
            SafeBox storage sb = boxhash2safebox[bh];
            if (block.timestamp - sb.lastTimeStamp >= sb.heirToInterval) {
                t_boxHashes[count] = bh;
                count++;
            }
        }
        if (count != boxHashes.length) {
            assembly {
                mstore(t_boxHashes, count)
            }
        }
        return t_boxHashes;
    }

    /**
     * @notice Transfer amount to heir if he has signed the will and will has matured
     * @param maturedBoxes Wills/Boxes which have matured
     */
    function transferAmountToHeirs(bytes32[] memory maturedBoxes) internal {
        for (uint256 i = 0; i < maturedBoxes.length; i++) {
            address[] memory ad = boxhash2safebox[maturedBoxes[i]].addresss;
            for (uint256 j = 0; j < ad.length; j++) {
                if (
                    boxhash2safebox[maturedBoxes[i]].withdrawSigned[ad[j]] &&
                    block.timestamp -
                        boxhash2safebox[maturedBoxes[i]].lastTimeStamp >=
                    boxhash2safebox[maturedBoxes[i]].heirToInterval
                ) {
                    uint256 amount = boxhash2safebox[maturedBoxes[i]]
                        .heirToBalance[ad[j]];
                    console.log("paying amt, to:", amount, ad[j]);
                    bool success = payable(ad[j]).send(amount);
                    if (success) {
                        boxhash2safebox[maturedBoxes[i]].heirToBalance[
                            ad[j]
                        ] = 0;
                        console.log("Funds Transferred");
                        emit FundsTransferred(amount, ad[j]);
                    }
                    // TODO add else and gas optimization cond
                }
            }
        }
    }

    /**
     * @notice chainlink keeper function which checks which boxes have matured
     * @return upkeepNeeded :bool value which tells if some will/box has matured
     * @return performData :bytes encoded data of matured will/box
     */
    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        bytes32[] memory boxes = getMaturedBoxes();
        upkeepNeeded = boxes.length > 0;
        performData = abi.encode(boxes);
        return (upkeepNeeded, performData);
    }

    /**
     * @notice chainlink keeper function which transfer the amounts to heirs if any will/box has matured
     * @param performData bytes encoded data of matured will/box
     */
    function performUpkeep(bytes calldata performData) external override {
        bytes32[] memory maturedBoxes = abi.decode(performData, (bytes32[]));
        transferAmountToHeirs(maturedBoxes);
    }

    // Chainlink keeper funciton ends

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }

    // Public Getter Setter Funcitons

    /**
     * @notice get heir amount from owner add
     * @param owner owner address
     * @param heir heir address
     * @return amount
     */
    function getHeirAmountFromOwner(address owner, address heir)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[user2boxhash[owner]].heirToBalance[heir];
    }

    /**
     * @notice get heir amount from box hash
     * @param boxhash boxhash
     * @param heir heir address
     * @return amount
     */
    function getHeirAmountFromOwner(bytes32 boxhash, address heir)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[boxhash].heirToBalance[heir];
    }

    /**
     * @notice get if heir has signed the will/box
     * @param owner owner address
     * @param heir heir address
     * @return bool
     */
    function getHeirWithdrawCounterFromOwner(address owner, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[user2boxhash[owner]].withdrawSigned[heir];
    }

    /**
     * @notice get if heir has signed the will/box from boxhash
     * @param boxhash boxhash
     * @param heir heir address
     * @return bool
     */
    function getHeirWithdrawCounterFromBoxHash(bytes32 boxhash, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[boxhash].withdrawSigned[heir];
    }

    /**
     * @notice get all the registered heirs array
     */
    function getSafeBoxHeirsFromOwner(address owner)
        public
        view
        returns (address[] memory)
    {
        return boxhash2safebox[user2boxhash[owner]].addresss;
    }

    /**
     * @notice get all the registered heirs array from box hash
     */
    function getSafeBoxHeirsFromBoxHash(bytes32 boxhash)
        public
        view
        returns (address[] memory)
    {
        return boxhash2safebox[boxhash].addresss;
    }

    /**
     * @notice get safe box details
     */
    function getSafeBoxDetailsFromOwner(address owner)
        public
        view
        returns (
            bytes32,
            uint256,
            uint256
        )
    {
        return (
            boxhash2safebox[user2boxhash[owner]].boxhash,
            boxhash2safebox[user2boxhash[owner]].heirToInterval,
            boxhash2safebox[user2boxhash[owner]].lastTimeStamp
        );
    }

    /**
     * @notice get safe box details from boxhash
     */
    function getSafeBoxDetailsFromBoxHash(bytes32 boxhash)
        public
        view
        returns (
            bytes32,
            uint256,
            uint256
        )
    {
        return (
            boxhash2safebox[boxhash].boxhash,
            boxhash2safebox[boxhash].heirToInterval,
            boxhash2safebox[boxhash].lastTimeStamp
        );
    }

    /**
     * @notice recieve funds
     */
    receive() external payable {
        emit FundsAdded(msg.value, address(this).balance, msg.sender);
    }
}
